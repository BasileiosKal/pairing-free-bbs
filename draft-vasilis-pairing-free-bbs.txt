



CFRG                                                            V. Kalos
Internet-Draft                                                     MATTR
Intended status: Informational                            30 August 2023
Expires: 2 March 2024


                      Pairing Free BBS Signatures
                 draft-vasilis-pairing-free-bbs-latest

Abstract

   TODO Abstract

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 2 March 2024.

Copyright Notice

   Copyright (c) 2023 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  Core Scheme Definition
     3.1.  Signature Generation
     3.2.  Pairing Free Signature Verification
     3.3.  Proof Generation
   4.  Deployments
     4.1.  Publicly Verifiable BBS Proofs
       4.1.1.  Public Keys Generation
       4.1.2.  ProofVerify
     4.2.  Privately Verifiable BBS Proofs
       4.2.1.  Public Key Generation
       4.2.2.  ProofVerify
   5.  Utility Operations
     5.1.  Public Keys Deserialization
   6.  Security Considerations
   7.  IANA Considerations
   Appendix A.  Acknowledgments
   Author's Address

1.  Introduction

   TODO Introduction

2.  Conventions and Definitions

   {::boilerplate bcp14-tagged}

3.  Core Scheme Definition

3.1.  Signature Generation

signature = ExtendedSign(SK, PK, header, messages)

Inputs:

- SK (REQUIRED), a non negative integer mod r outputted by the KeyGen
                 operation.
- PK (REQUIRED), an octet string of the form outputted by the SkToPkG1
                   operation provided the above SK as input.
- PK_2 (OPTIONAL), an octet string of the form outputted by the SkToPkG2
                   operation provided the above SK as input. If not
                   supplied, it defaults to the empty octet string ("").
- header (OPTIONAL), an octet string containing context and application
                     specific information. If not supplied, it defaults
                     to an empty string.
- messages (OPTIONAL), a vector of scalars. If not supplied, it defaults
                       to the empty array "()".

Deserialization:


Procedure:

1. sig = Sign(SK, PK, header, messages)
2. if sig is INVALID, return INVALID
3. (A, e) = octets_to_signature(sig)

4. sk~ = hash_to_scalar(serialize(SK, e))
5. PK_1_bar = P1 * sk~
6. A_bar = A * sk~

7. c = hash_to_scalar(serialize(PK_1_bar, A_bar, e, messages,
                                                       header, PK))

8. sk^ = sk~ + SK * c
9. return (A, e, sk^, c)

3.2.  Pairing Free Signature Verification

result = ExtendedVerify(signature, PK, header, messages)

Inputs:

- signature (REQUIRED), an octet string of the form outputted by the
                        Sign operation.
- PK_1 (REQUIRED), an octet string of the form outputted by the SkToPkG1
                   operation provided the above SK as input.
- PK_2 (OPTIONAL), an octet string of the form outputted by the SkToPkG2
                   operation provided the above SK as input. If not
                   supplied, it defaults to the empty octet string ("").
- header (OPTIONAL), an octet string containing context and application
                     specific information. If not supplied, it defaults
                     to an empty string.
- messages (OPTIONAL), a vector of scalars. If not supplied, it defaults
                       to the empty array "()".

Parameters:

- P1, fixed point of G1, defined by the ciphersuite.
- create_generators, an operation that returns a number of generator
                     points, defined by the ciphersuite.

Definitions:

- L, is the non-negative integer representing the number of signed
     messages.

Outputs:

- result, either VALID or INVALID.

Deserialization:

1.  signature_result = octets_to_signature(signature)
2.  if signature_result is INVALID, return INVALID
3.  (A, e, sk^, c) = signature_result

4.  PublicKeys = deserialize_public_keys(PK)
5.  if PublicKeys is INVALID, return INVALID
6.  (PK_1, PK_2) = PublicKeys

7.  W = octets_to_pubkey(PK_1)
8.  if W is INVALID, return INVALID

9.  L = length(messages)
10. (msg_1, ..., msg_L) = messages

Procedure:

1.  (Q_1, H_1, ..., H_L) = create_generators(L+1, PK_2, header)
2.  domain = calculate_domain(PK_2, Q_1, (H_1, ..., H_L), header)
3.  if domain is INVALID, return INVALID
4.  B = P1 + Q_1 * domain + H_1 * msg_1 + ... + H_L * msg_L

5.  if e(A, W + P2 * e) * e(B, -P2) != Identity_GT, return INVALID

6.  PK_1_bar = P1 * sk^ - W * c
7.  D = B + A * (-e)
8.  A_bar = A * sk^ + D * (-c)

9.  cv = hash_to_scalar(serialize(PK_1_bar, A_bar, e, messages,
                                                         header, PK))

10. if c != cv, return INVALID

11. return VALID

3.3.  Proof Generation

proof = ExtendedProofGen(signature, PK, header, ph,
                                            messages, disclosed_indexes)

Inputs:

- signature (REQUIRED), an octet string of the form outputted by the
                        Sign operation.
- PK (REQUIRED), an octet string of the form outputted by the SkToPkG1
                   operation provided the above SK as input.
- header (OPTIONAL), an octet string containing context and application
                     specific information. If not supplied, it defaults
                     to an empty string.
- ph (OPTIONAL), an octet string containing the presentation header. If not
                 supplied, it defaults to an empty string.
- messages (OPTIONAL), a vector of scalars. If not supplied, it defaults
                       to the empty array "()".
- disclosed_indexes (OPTIONAL), vector of unsigned integers in ascending
                                order. Indexes of disclosed messages. If
                                not supplied, it defaults to the empty
                                array "()".

Procedure:

1. proof = ProofGen(PK, signature, PK, header, ph, messages,
                                                      disclosed_indexes)
2. if proof is INVALID, return INVALID
3. return proof

4.  Deployments

4.1.  Publicly Verifiable BBS Proofs

   Publicly verifiable BBS scheme.

4.1.1.  Public Keys Generation

   PK = SkToPks(SK)

   Inputs:

   - SK (REQUIRED), a secret integer such that 0 < SK < r.

   Outputs:

   - PK, a public key encoded as an octet string.

   Procedure:

   1. W_1 = SK * P1
   2. W_2 = SK * P2
   2. return point_to_octets_g1(W_1) || point_to_octets_g2(W_2)

4.1.2.  ProofVerify

result = ProofVerify(SK, PK, proof, header, ph,
                     disclosed_messages,
                     disclosed_indexes)

Inputs:

- PK (REQUIRED), an octet string of the form outputted by the SkToPk
                 operation.
- proof (REQUIRED), an octet string of the form outputted by the
                    ProofGen operation.
- header (OPTIONAL), an optional octet string containing context and
                     application specific information. If not supplied,
                     it defaults to an empty string.
- ph (OPTIONAL), an octet string containing the presentation header. If not
                 supplied, it defaults to an empty string.
- disclosed_messages (OPTIONAL), a vector of input_messages. If not
                                 supplied, it defaults to the empty
                                 array "()".
- disclosed_indexes (OPTIONAL), vector of unsigned integers in ascending
                                order. Indexes of disclosed messages. If
                                not supplied, it defaults to the empty
                                array "()".

Parameters:

- P1, fixed point of G1, defined by the ciphersuite.

Outputs:

- result, either VALID or INVALID.

Deserialization:

1.  proof_result = octets_to_proof(proof)
2.  if proof_result is INVALID, return INVALID
3.  (Abar, Bbar, r2^, r3^, commitments, cp) = proof_result

4.  public_keys = deserialize_public_keys(PK)
5.  if public_keys is INVALID, return INVALID
6.  (PK_1, PK_2) = public_keys
7.  W = octets_to_pubkey(PK_2)
8.  if W is INVALID, return INVALID

9.  (i1, ..., iR) = disclosed_indexes
10. msg_scalars = messages_to_scalars(messages)

Procedure:

1. init_res = ProofVerifyInit(PK, proof_result, header, msg_scalars,
                                                      disclosed_indexes)
3. challenge = ProofChallengeCalculate(init_res, disclosed_indexes,
                                                        msg_scalars, ph)
4. if cp != challenge, return INVALID
5. if e(Abar, W) * e(Bbar, -BP2) != Identity_GT, return INVALID
6. return VALID

4.2.  Privately Verifiable BBS Proofs

4.2.1.  Public Key Generation

4.2.2.  ProofVerify

result = ProofVerify(SK, PK, proof, header, ph,
                     disclosed_messages,
                     disclosed_indexes)

Inputs:

- PK (REQUIRED), an octet string of the form outputted by the SkToPk
                 operation.
- proof (REQUIRED), an octet string of the form outputted by the
                    ProofGen operation.
- header (OPTIONAL), an optional octet string containing context and
                     application specific information. If not supplied,
                     it defaults to an empty string.
- ph (OPTIONAL), an octet string containing the presentation header. If not
                 supplied, it defaults to an empty string.
- disclosed_messages (OPTIONAL), a vector of input_messages. If not
                                 supplied, it defaults to the empty
                                 array "()".
- disclosed_indexes (OPTIONAL), vector of unsigned integers in ascending
                                order. Indexes of disclosed messages. If
                                not supplied, it defaults to the empty
                                array "()".

Parameters:

- P1, fixed point of G1, defined by the ciphersuite.

Outputs:

- result, either VALID or INVALID.

Deserialization:

1. proof_result = octets_to_proof(proof)
2. if proof_result is INVALID, return INVALID
3. (Abar, Bbar, r2^, r3^, commitments, cp) = proof_result
4. W = octets_to_pubkey(PK)
5. if W is INVALID, return INVALID
6. (i1, ..., iR) = disclosed_indexes
7. msg_scalars = messages_to_scalars(messages)

Procedure:

1. init_res = ProofVerifyInit(PK, proof_result, header, msg_scalars,
                                                      disclosed_indexes)
3. challenge = ProofChallengeCalculate(init_res, disclosed_indexes,
                                                        msg_scalars, ph)
4. if cp != challenge, return INVALID
5. if Abar * SK != Bbar, return INVALID
6. return VALID

5.  Utility Operations

5.1.  Public Keys Deserialization

   (PK_1, PK_2) = deserialize_public_keys(PK)

   Inputs:

   PK (REQUIRED)

   Parameters:

   - octet_point_length_g1
   - octet_point_length_g2

   Procedure:

   1. pk_size = octet_point_length_g1 + octet_point_length_g2
   2. if length(PK) != pk_size, return INVALID
   3. PK_1 = PK[0..octet_point_length_g1]
   4. PK_2 = PK[octet_point_length_g1 + 1..PK_size]
   5. return (PK_1, PK_2)

6.  Security Considerations

   TODO Security

7.  IANA Considerations

   This document has no IANA actions.

Appendix A.  Acknowledgments

   TODO acknowledge.

Author's Address

   Vasilis Kalos
   MATTR
   Email: vasilis.kalos@mattr.global
